#!/bin/bash -e
# Copyright (C) 2023 Simo Sorce <simo@redhat.com>
# SPDX-License-Identifier: Apache-2.0

source ${TESTSSRCDIR}/helpers.sh
SERVER_PORT=12345
title PARA "Test SSL_CTX creation"
./tlsctx

title PARA "Test an actual TLS connection"
rm -f ${TMPPDIR}/s_server_input
rm -f ${TMPPDIR}/s_server_output

# Set up command fifo
mkfifo ${TMPPDIR}/s_server_input
exec 3<>${TMPPDIR}/s_server_input

openssl s_server -accept $SERVER_PORT -key ${PRIURI} -cert ${CRTURI} <&3 &
SERVER_PID="$!"


echo "[$(date -u)] Waiting for server socket"
SERVER_STATE="down"
set +e
for i in {1..30}
do
   nc -zv localhost $SERVER_PORT > /dev/null
   if [ $? -eq 0 ]; then
      SERVER_STATE="up"
      break
   fi
   sleep 0.5
done
echo "[$(date -u)] Server is $SERVER_STATE"
set -e

# The client will error when the server drops the connection.
set +e
openssl s_client -connect localhost:$SERVER_PORT -quiet > ${TMPPDIR}/s_server_output &
CLIENT_PID="$!"
set -e

# Wait to make sure client is connected
sleep 0.5

# Send command to the client
echo " TLS SUCCESSFUL " >&3

echo "Shutting down server"
# s_server seem to be confused if Q comes in too early
sleep 0.5
echo "Q" >&3
wait_for_process_or_kill "$SERVER_PID" 3

# Tear down command fifo
exec 3>&-
rm -f ${TMPPDIR}/s_server_input

echo " Waiting for openssl s_client ($CLIENT_PID) to complete"
wait_for_process_or_kill "$CLIENT_PID" 3

echo "Check message was successfully delivered over TLS"
grep " TLS SUCCESSFUL " ${TMPPDIR}/s_server_output

exit 0

